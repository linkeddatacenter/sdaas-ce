# Copyright (C) 2019 LinkedData.Center - All Rights Reserved
# Permission to copy and modify is granted under the MIT license
if [ ! -z ${__module_bg_reasoning+x} ]; then return ; else __module_bg_reasoning=1 ; fi

SD_INCLUDE service_registry
SD_INCLUDE curl_utils

SD_REQUIRES_CMD mktemp realpath basename dirname gzip head cut tail

# Reasoner engine must be local to sdaas platform
SD_REASONER_ENDPOINT=${SD_REASONER_ENDPOINT:-"http://localhost:8080/bigdata"}

# @description create a reasoner based on blazegraph extensions
# each reasoner can have an archetype (ie. specific features pre-configured). e.g.:
#  . **rdfs** implements an rdfs triplestore reasoner
#  . **geo** is able extends sparql triplestore  with [geospatial search](https://wiki.blazegraph.com/wiki/index.php/GeoSpatial)
#  . **lexical** add lucene  [textual indices](https://wiki.blazegraph.com/wiki/index.php/FullTextSearch) to triplestore
#  . **kbplus** is a quadstore with both textual and geospatial features installed
# beside standard reasoners there is also a default sparql 1.1. quadstore with name **kb**.
# knowledge base archetipes are in the scripts/archetipes directory
#
# @arg $1 a reasoner archetype
# @arg $2 force the name of the namespace
#
function SD_CREATE_REASONER {
	local archetype="$1"
	local namespace="${2:-"${archetype}-${RANDOM}"}"

	SD_DEBUG_INFO "In SD_CREATE_REASONER archetype=$archetype namespace=$namespace"
	
	local archetipes="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/archetypes"
		
	test -f  "${archetipes}/${archetype}.txt"  || SD_FATAL_ERROR "Invalid reasoner archetype ($archetype)."

	local description=$(cat "$archetipes/${archetype}.txt" | sed "s/%namespace/$namespace/g")
	local cmdResult="$(curl -s -X POST \
		--data-binary "$description" \
		--header 'Content-Type:text/plain' \
		"$SD_REASONER_ENDPOINT/namespace")" || SD_FATAL_ERROR "SD_CREATE_REASONER error creating namespace"
	SD_DEBUG_INFO "$cmdResult"
	
	reasonerId=$(SD_REGISTER_SERVICE "$SD_REASONER_ENDPOINT|$namespace|$archetype" $namespace)
	
	## Load specific archetipe resources
	if [ -r "${archetipes}/${archetype}.ttl" ] ; then
		SD_REASONER_LOAD $reasonerId "${archetipes}/${archetype}.ttl" turtle "urn:sdaas:tbox:${archetype}"
	fi
	echo "$reasonerId"
}


function SD_DESTROY_REASONER {
	local reasonerId="$1"
		
	SD_DEBUG_INFO "In SD_DESTROY_REASONER reasonerId=${reasonerId}"
	
	local endpoint namespace archetype
	IFS='|' read  endpoint namespace archetype <<< $(SD_FETCH_SERVICE "$reasonerId")
	
	## Ignore errors in deleting a reasoner	
	SD_DEBUG_INFO "$(curl -s -X DELETE "$endpoint/namespace/$namespace")"
	SD_UNREGISTER_SERVICE "$reasonerId"
}



# @description a sparql query client output goes to stdout
#
# @example
#   SD_REASONER_QUERY rdfs text/csv "select * where {?s ?p ?o} LIMIT 1"
#   SD_REASONER_QUERY rdfs text/csv "@path/to/input_file_with_query"
#
# @arg $1 the reasoner reference
# @arg $2 mime type for accepted result (i.e. text/csv or text/turtle) or some shortcuts:
#      "csv" a shortcut for text/csv
#      "csv-h" text/csv without  headers
# 	   "csv-1" return just first line (removing headers) in csv
# 	   "csv-f1" return just first field in first line (removing headers) in csv
#	   "bool" return true or false if result contains <value>true</value>
#	   "xml" a shortcut for application/sparql-results+xml
# @arg $3 a string with a valid sparql query statement (with extension) or a filename prefixed by the  @ character
#
# @exitcode 0  If successfull.
# @exitcode >0 On failure
function SD_REASONER_QUERY {
	local reasonerId="$1"
	local request="$2"
	local query="$3"
	
	SD_DEBUG_INFO "In SD_REASONER_QUERY with reasonerId=$reasonerId request='$request' query='${query:0:40}'"

	local endpoint namespace archetype
	IFS='|' read  endpoint namespace archetype <<< $(SD_FETCH_SERVICE "$reasonerId")
	
	local accept
	case "$request" in
		csv*) accept="text/csv" ; ;;
		xml|bool) accept="application/sparql-results+xml";  ;;
		*) accept="$request"; ;;
	esac	

	local outputBuffer=$(SD_MK_DEBUG_TMP_FILE sparql_query_output)
	_SD_CURL_POST \
		"${endpoint}/namespace/${namespace}/sparql" \
		"$outputBuffer" \
		"$query" \
		"application/sparql-query" \
		"$accept" \
	|| SD_FATAL_ERROR "SD_REASONER_QUERY failed, see $outputBuffer"	
	SD_DEBUG_INFO "See unfiltered output in $outputBuffer"
	
	# Post processing
	case "$request" in
		csv-h) tail -n +2 "$outputBuffer"; ;;
		csv-1) head -2 "$outputBuffer" | tail -1; ;;
		csv-f1) head -2 "$outputBuffer" | tail -1 | cut --delimiter=',' -f1; ;;
		bool) if grep -q "<boolean>true</boolean>" "$outputBuffer" ; then echo true;  else echo false; fi; ;;
		*) cat "$outputBuffer"; ;;
	esac	
	
	if [ $SD_DEBUG -eq 0 ]; then  rm -f "$traceFile" "$outputBuffer" ; fi
}


function SD_REASONER_UPDATE {
	local reasonerId="$1"
	local data="$2"
		
	SD_DEBUG_INFO  "In SD_REASONER_UPDATE with reasonerId=$reasonerId data='${data:0:40}'"
	
	local endpoint namespace archetype
	IFS='|' read  endpoint namespace archetype <<< $(SD_FETCH_SERVICE "$reasonerId")

	local output=$(SD_MK_DEBUG_TMP_FILE SD_REASONER_UPDATE_output)	
	_SD_CURL_POST \
		"${endpoint}/namespace/${namespace}/sparql" \
		"$output" \
		"$data" \
		"application/sparql-update" \
	|| SD_FATAL_ERROR "SD_REASONER_UPDATE returned $httpStatus: see $output"
	
	if [ $SD_DEBUG -eq 0 ]; then  rm -f "$output"; fi
}


#
# Simple loading of a a file into a reasoner
# Reasoner engine is local load a file else use proxy and gizip it
# Format can be: guess(default), 'turtle', 'ntriples', 'rdfxml', 
function SD_REASONER_LOAD {
	local reasonerId="$1"
	local inputFile="$2"
	local format="${3:-guess}"
	local graphName="${4:-'urn:default:graph'}"

	local extension
	case $format in
		turtle)   extension='ttl'; ;;
		ntriples) extension='nt'; ;;
		rdfxml)   extension='rdf'; ;;
		*)        extension="${inputFile##*.}"; ;;
	esac
	
	local sharedFile=$(mktemp --tmpdir "r-XXXXXXXXXX.$extension.gz")
	gzip -c "$inputFile" > "$sharedFile"
	chmod +r "$sharedFile"
	
    SD_REASONER_UPDATE $reasonerId "LOAD <file://${sharedFile}> INTO GRAPH <$graphName>"
	if [ $SD_DEBUG -lt 10 ]; then  rm -f "$sharedFile" ; fi	  
}



